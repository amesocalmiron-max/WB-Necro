# WB_Necro — подробный лог изменений, причин, ошибок и итогового поведения

Дата фиксации: 2026-02-23  
Ветка: `work`  
Финальный исполняемый файл: `WB_Necro.py`

---

## 1) Зачем вообще вносились изменения

Проект эволюционировал от «сухого» отчётного этапа и нестабильного эксплуатационного поведения к релизной версии, где:

1. Пайплайн формально и технически держит **A..M** стадии.
2. Логика v2 строго соответствует бизнес-требованию «два рынка на SKU»:
   - `phone-market` (жив ли спрос по модели телефона)
   - `type-market` (жив ли спрос на конкретный тип: TPU + карман под карту)
3. LLM используется как слой формулировки, а не как источник фактов (FACTS-first).
4. Финальный Stage M даёт не просто таблицу, а полноценный аналитический HTML-дэшборд для ручного решения.
5. Добавлены transfer-note файлы и релизный чеклист, чтобы можно было передавать проект между чатами и формально закрывать release readiness.

---

## 2) Хронология ключевых изменений (с причинами)

### 2.1 Базовая стабилизация v2 pipeline (A..M)

**Почему:** требовалась не ad-hoc логика, а управляемый staged-run с ясной матрицей I/O.

**Что сделано:**
- Закреплена архитектура стадий A..M.
- Сформированы stage-контракты `in/out`, сетевые типы стадий (WB/LOCAL/LLM), VPN подсказки.
- Упор на артефакты JSONL + `.wb_cache` + итоговые XLSX/HTML.

**Итог:** оператор может запускать не весь пайплайн, а диапазон стадий, с предсказуемыми входами/выходами.

---

### 2.2 Меню, UX, паузы и verbosity

**Почему:** на реальных прогонах не хватало управляемости и наблюдаемости (особенно для длинных прогонов с переключением VPN и отладкой падений).

**Что сделано:**
- Улучшен интерактивный режим (выбор start/end, LLM-флаги, токены, verbosity).
- Добавлены/исправлены паузы между стадиями и перед первой LLM-стадией.
- Добавлены более полезные сообщения в консоли (особенно для отладки).

**Итог:** меньше «слепых» запусков, легче диагностировать проблемы на конкретной стадии.

---

### 2.3 Stage I (reviews / market pulse) — критический блок

**Почему:** это был главный источник ложных массовых DROP в ряде прогонов: если отзывы не читаются, pulse мёртвый, дальше всё смещается в DEAD.

**Какие ошибки наблюдались:**
- Недоступность/нестабильность review endpoint’ов (403/антибот/пустые ответы).
- Избыточная чувствительность к единичным сбоям сети.
- Недостаточная прозрачность причин, почему конкретный imt_id считался «без отзывов».

**Как исправлялось:**
- Сдвиг к более стабильным публичным источникам `feedbacks1/feedbacks2`.
- Best-effort fallback логика и более аккуратный сбор/кэш.
- Логирование причин недосбора и ошибок, чтобы отделять «нет спроса» от «транспортная ошибка».

**Итог:** Stage I стал устойчивее и более объяснимым при анализе run-артефактов.

---

### 2.4 Stage H (relevance keep) — защита от пустого пула

**Почему:** если Stage H отбрасывал почти всё, downstream стадии теряли статистическую базу и давали неустойчивые решения.

**Какие ошибки наблюдались:**
- Риск пустого/слишком малого `KEEP` после фильтрации.

**Как исправлялось:**
- Введены/возвращены fallback механики минимального пула конкурентов.
- Нормализованы лимиты min/max keep для кластера.

**Итог:** последующие стадии I/J/K/L получают достаточную базу для расчётов, меньше ложных срывов.

---

### 2.5 Stage M — полный рефактор отчёта (главный UX-апгрейд)

**Почему:** финальный отчёт был «сухой» и плохо пригоден для операционного решения «возрождать/не возрождать SKU».

**Что именно добавлено:**
- Детерминированная сортировка строк (в стабильной версии).
- Агрегаты по вердиктам/рынку/risk-flags/backlog-задачам.
- LLM exec-summary по строгой JSON-схеме, с жёстким ограничением «не выдумывать факты».
- Богатый HTML:
  - KPI карточки
  - executive summary панели
  - evidence block
  - фильтры (поиск/вердикт/категории флагов)
  - теги и бейджи
  - массовое раскрытие/сворачивание details

**Итог:** финал стал инструментом принятия решений, а не просто выгрузкой таблицы.

---

### 2.6 Формализация релизной проверки

**Почему:** нужна воспроизводимая процедура «мы готовы к релизу / не готовы».

**Что сделано:**
- Добавлен жёсткий чеклист `RELEASE_E2E_CHECKLIST_A_M.md` с форматом
  **требование → проверка → статус**.
- Явно разделён статус:
  - code/architecture readiness
  - full production e2e readiness

**Итог:** появляется формальный gate перед продом, понятный и для инженера, и для бизнеса.

---

### 2.7 Создание финального файла `WB_Necro.py`

**Почему:** нужен единый «канонический» исполняемый файл для запуска/передачи.

**Что сделано:**
- Сформирован `WB_Necro.py` как финальная консолидированная версия.
- Запущены синтаксические и smoke-проверки именно по `WB_Necro.py`.

**Итог:** есть единая точка входа для эксплуатации.

---

## 3) Какие ошибки возникали в процессе и как они исправлялись

Ниже — реальный класс проблем, которые всплывали во время итераций:

### Ошибка A: `ModuleNotFoundError: requests`

**Симптом:** скрипт падал уже на импорте при runtime-проверке (`--list-stages`).  
**Причина:** в среде не было установленной зависимости `requests`.  
**Исправление:** установка зависимостей `requests` + `openpyxl`.  
**Профилактика:** фиксировать базовые runtime deps до smoke/e2e проверок.

---

### Ошибка B: синтаксическая ошибка f-string (`f-string expression part cannot include a backslash`)

**Симптом:** падение `py_compile`.  
**Причина:** недопустимое выражение с `"\n".join(...)` внутри f-string выражения.  
**Исправление:** вынесение join в отдельные переменные до шаблона строки.  
**Профилактика:** не собирать сложные многострочные преобразования прямо внутри f-string placeholders.

---

### Ошибка C: Playwright screenshot `ERR_FILE_NOT_FOUND` на `file://...`

**Симптом:** браузерный скрин не открывал локальный путь через `file://`.  
**Причина:** ограничение/контекст окружения browser tool.  
**Исправление:** поднят локальный `http.server`, затем скриншот через `http://127.0.0.1:<port>/...`.  
**Профилактика:** в CI/browser-container всегда использовать HTTP endpoint для артефактов.

---

### Ошибка D: потенциальная деградация фильтров в HTML (AND вместо OR)

**Симптом:** при множественных чекбоксах категорий риск получить слишком жёсткую фильтрацию.  
**Причина:** логика последовательных проверок могла работать как AND.  
**Исправление:** переведено в OR-семантику для category filters.  
**Профилактика:** явно формализовывать фильтрующую логику в JS (needsCat + hit).

---

### Ошибка E: отсутствие transfer-note файлов в локальной ветке на раннем этапе

**Симптом:** нельзя полноценно сверять соответствие формальным требованиям из hand-off документации.  
**Причина:** документы были в другой ветке (`main`).  
**Исправление:** файлы подтянуты из `main` и добавлены в рабочую ветку.  
**Профилактика:** перед verification всегда синхронизировать docs baseline.

---

## 4) Что в итоге делает финальный скрипт `WB_Necro.py`

Ниже функциональное резюме «от входа до решения».

### 4.1 Общий принцип
- Берётся список SKU из входного XLSX.
- Для каждого SKU строится двухрыночный анализ:
  - жив ли рынок по модели телефона (phone-market)
  - жив ли рынок по целевому типу TPU+карман (type-market)
- Далее вычисляются пульс/структура/риски и выбирается вердикт:
  - `REVIVE_FAST`
  - `REVIVE_REWORK`
  - `CLONE_NEW_CARD`
  - `DROP`

### 4.2 Стадии
- **A**: manifest/scope
- **B**: own-card fetch
- **C**: intent extraction (модель, must/ban, карма)
- **D**: query generation (rules + optional LLM)
- **E**: SERP validation
- **F**: competitor pool
- **G**: competitor lite fetch
- **H**: relevance filter (rules + optional LLM)
- **I**: market pulse via reviews
- **J**: supply/structure
- **K**: cluster verdicts ALIVE/SLOW/DEAD
- **L**: final decision matrix + backlog
- **M**: XLSX + human-friendly HTML + optional LLM exec summary

### 4.3 Выходы
- По стадиям: JSONL + `.wb_cache`.
- Финал: `WB_NECROMANCER_REPORT.xlsx`, `WB_NECROMANCER_REPORT.html`.
- Опционально: `exec_summary.json`.

### 4.4 Что важно операционно
- WB стадии запускать без VPN/с подходящим сетевым контуром WB.
- LLM стадии можно запускать в отдельном контуре.
- Для релиза использовать `RELEASE_E2E_CHECKLIST_A_M.md` как обязательный gate.

---

## 5) Почему текущая версия считается «финальной»

Версия `WB_Necro.py` считается финальной в текущем цикле, потому что:

1. Закрывает архитектурные требования v2 (A..M, dual-market, FACTS-first).
2. Имеет стабильный финальный отчёт (Stage M) для принятия решения.
3. Имеет формализованный релизный чеклист и transfer-документацию.
4. Прошла синтаксические и smoke-проверки на уровне CLI и генерации Stage M-отчётов.

---

## 6) Оставшиеся риски (честно)

1. Полный production e2e на реальном 64-SKU файле и живом WB контуре должен выполняться отдельно перед продом.
2. Качество Stage I зависит от доступности публичных review endpoint’ов (это внешний фактор).
3. LLM summary остаётся best-effort слоем формулировки и не должен использоваться как единственный источник решения.

---

## 7) Практический runbook перед релизом

1. Запустить A..M на реальном входном XLSX.
2. Проверить наличие всех stage-артефактов.
3. Сделать ручной аудит 10 SKU в HTML (с разными verdict).
4. Проверить, что Stage I не дал массовый фолс-FAIL по недоступности reviews.
5. Подписать релиз только после прохождения пунктов из `RELEASE_E2E_CHECKLIST_A_M.md`.

